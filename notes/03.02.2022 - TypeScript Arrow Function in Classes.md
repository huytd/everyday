# 03.02.2022 - TypeScript/Arrow Function in Classes

In JavaScript/TypeScript, you can create a class with either a normal function or an arrow function:

```typescript
class Foo {
    hello() {
        return "Hello";
    }

    foo = () => {
        return "Hello";
    }
}
```

There is a memory and performance impact when doing this. The [Handbook](https://www.typescriptlang.org/docs/handbook/2/classes.html#arrow-functions) only mentioned it in a single line without any further explanation: 

> This will use more memory, because each class instance will have its own copy of each function defined this way

I was confused about this statement, so I decided to take a closer look to find out why.

---

First, let's compile the following TypeScript snippet to JavaScript, this is what we get:

```javascript
"use strict";
class Foo {
    constructor() {
        this.foo = () => {
            return "Hello";
        }    
    }

    hello() {
        return "Hello";
    }
}
```

Now it makes more sense. The `foo` arrow function becomes a property of the `Foo` class and gets defined inside the class's constructor. Because the syntax that we are using to define the `foo` function is actually class's property definition syntax:

```typescript
class A {
    prop = <value>;
}
```

If you inspect the prototype of the `Foo` class, what you see is:

```
Class Foo
    ┗ Prototype
        ┣ constructor: function() { ... }
        ┗ hello: function() { ... }
```

Every instance of the `Foo` class will get its own version of the `foo` method, which will be created at runtime, inside the constructor. And it will take a lot more memory.

There is a performance impact when defining a class's method as an arrow function like this as well.

As we already know, most JavaScript engines do a very good job to optimize code execution in various ways. One of these techniques is to detect if a function is being called over and over again (a hot function). With the class's function, the engine easily knows that it's the same function in the class prototype and it can do the optimization if needed. But with the case of the arrow function, we are technically calling different functions from different instances, so, the JS engine won't be able to do any optimization.

You can check the benchmark between the two cases in Nicolas Charpentier's article: [Arrow Functions in Class Properties Might Not Be As Great As We Think](https://www.charpeni.com/blog/arrow-functions-in-class-properties-might-not-be-as-great-as-we-think), but be mindful that the article was written from 2017, and the way browser engines works might change a lot since then.